#!/usr/bin/env python3
# --------------------------------------------------------------
# main.py ‚Äì A‚ÄëJewel WhatsApp Bot (OAuth token version)
# --------------------------------------------------------------
"""
High‚Äëlevel flow
1Ô∏è‚É£  Customer says "hi / hello / menu". Bot checks Shopify for the phone:
    ‚Ä¢ Existing ‚Üí greeting + *Menu* button.
    ‚Ä¢ New      ‚Üí registration + *Sign‚ÄëUp* CTA.

2Ô∏è‚É£  Main menu (interactive):
    ‚Ä¢ Catalog ‚Üí Shopify collections ‚Üí products ‚Üí variants.
    ‚Ä¢ Custom Jewellery ‚Üí ask for the piece name ‚Üí thank‚Äëyou & finish.

3Ô∏è‚É£  Variant selection ‚Üí add to a temporary cart ‚Üí ask **Retail** or **B2B**.

4Ô∏è‚É£  Customer types **checkout** ‚Üí bot totals the cart,
    creates a Razorpay payment‚Äëlink, and sends a "Pay Now" CTA.
    Payment‚Äëlink message is generated by Gemini (different for Retail vs B2B).

5Ô∏è‚É£  Razorpay callback (GET) or webhook (POST) notifies the user:
    ‚Ä¢ B2B ‚Üí "Download Now" button (digital 3‚ÄëD file).
    ‚Ä¢ Retail ‚Üí "We will contact you soon" message.

6Ô∏è‚É£  Any other Shopify‚Äërelated query (order status, gift‚Äëcard balance,
    discount codes, inventory, etc.) is detected, the appropriate Shopify
    endpoint is called (read scopes already granted), and Gemini summarises
    the result in professional Hinglish.

7Ô∏è‚É£  Cron job (21‚Äë23 h) ‚Üí reminder "üõí aapka cart abhi bhi hai ‚Äì checkout ya menu dabayein".

All outgoing messages are generated by Gemini with the system prompts
defined in ``SYSTEM_PROMPTS`` (Hinglish written with Latin letters).
"""

import os
import json
import hmac
import hashlib
import logging
import threading
import time
import re
from datetime import datetime
from dataclasses import dataclass, field
from typing import List, Dict, Optional

import requests
import gspread
import razorpay
from flask import Flask, request, jsonify
from google.oauth2.service_account import Credentials

# ------------------------------------------------------------------
# 1Ô∏è‚É£  Flask app & logger
# ------------------------------------------------------------------
app = Flask(__name__)

log = logging.getLogger("ajewel_bot")
log.setLevel(logging.INFO)
handler = logging.StreamHandler()
handler.setFormatter(logging.Formatter("%(asctime)s | %(levelname)s | %(message)s"))
log.addHandler(handler)

# ------------------------------------------------------------------
# 2Ô∏è‚É£  Environment variables (add them in Render ‚Üí Environment)
# ------------------------------------------------------------------
def env(name: str, required: bool = True, default: str = "") -> str:
    """Read an env‚Äëvar; raise if required and missing."""
    val = os.getenv(name, default).strip()
    if required and not val:
        raise RuntimeError(f"‚ùå Missing required env‚Äëvar: {name}")
    return val


VERIFY_TOKEN        = env("VERIFY_TOKEN")
ACCESS_TOKEN        = env("ACCESS_TOKEN")
PHONE_NUMBER_ID     = env("PHONE_NUMBER_ID")
SHOPIFY_STORE       = env("SHOPIFY_STORE")
SHOPIFY_CLIENT_ID   = env("SHOPIFY_CLIENT_ID")
SHOPIFY_CLIENT_SECRET = env("SHOPIFY_CLIENT_SECRET")
RAZORPAY_KEY_ID     = env("RAZORPAY_KEY_ID")
RAZORPAY_KEY_SECRET = env("RAZORPAY_KEY_SECRET")
GEMINI_API_KEY      = env("GEMINI_API_KEY")
GOOGLE_CRED_JSON    = env("GOOGLE_CREDENTIALS", required=False)
SHEET_ID            = env("SHEET_ID", required=False)

# ------------------------------------------------------------------
# 3Ô∏è‚É£  Global objects
# ------------------------------------------------------------------
rzp_client = razorpay.Client(auth=(RAZORPAY_KEY_ID, RAZORPAY_KEY_SECRET))

# ------------------------------------------------------------------
# 4Ô∏è‚É£  OAuth token cache (thread‚Äësafe)
# ------------------------------------------------------------------
_token_cache = {
    "access_token": None,
    "expires_at": 0,
    "lock": threading.Lock(),
}


def _request_new_shopify_token() -> dict:
    url = f"https://{SHOPIFY_STORE}/admin/oauth/access_token"
    payload = {
        "grant_type": "client_credentials",
        "client_id": SHOPIFY_CLIENT_ID,
        "client_secret": SHOPIFY_CLIENT_SECRET,
    }
    headers = {"Content-Type": "application/x-www-form-urlencoded"}
    resp = requests.post(url, data=payload, headers=headers, timeout=10)
    resp.raise_for_status()
    return resp.json()


def get_shopify_access_token() -> str:
    with _token_cache["lock"]:
        now = int(time.time())
        if _token_cache["access_token"] and now < _token_cache["expires_at"] - 30:
            return _token_cache["access_token"]
        data = _request_new_shopify_token()
        _token_cache["access_token"] = data["access_token"]
        _token_cache["expires_at"] = now + int(data.get("expires_in", 86400))
        log.info("Fetched new Shopify token (expires in %s secs)", data.get("expires_in"))
        return _token_cache["access_token"]


# ------------------------------------------------------------------
# 5Ô∏è‚É£  Session data class
# ------------------------------------------------------------------
@dataclass
class UserSession:
    phone: str
    step: str = "new"
    name: Optional[str] = None
    contact: Optional[str] = None
    email: Optional[str] = None
    company: Optional[str] = None
    gst: Optional[str] = None
    address: Optional[str] = None
    city: Optional[str] = None
    customer_type: Optional[str] = None   # "retail" | "b2b"
    cart: List[int] = field(default_factory=list)
    order_id: Optional[str] = None
    amount: Optional[float] = None


sessions: Dict[str, UserSession] = {}

# ------------------------------------------------------------------
# 6Ô∏è‚É£  Gemini system prompts (Hinglish ‚Äì Latin script)
# ------------------------------------------------------------------
SYSTEM_PROMPTS: Dict[str, str] = {
    "greeting": (
        "Tu A Jewel Studio ka professional WhatsApp assistant hai. "
        "Tera naam Akshay hai. Customer ko warmly welcome karo. "
        "Tone: Professional, warm, Hinglish. 2‚Äë3 lines max."
    ),
    "registration": (
        "Tu A Jewel Studio ka WhatsApp assistant hai. "
        "Customer pehli baar aa raha hai. Politely batao ki order ke liye Shopify account banana zaroori hai. "
        "Tone: Professional, helpful, Hinglish. 3‚Äë4 lines max."
    ),
    "catalog": (
        "Tu A Jewel Studio ka WhatsApp assistant hai. "
        "Customer catalog dekhna chahta hai. Professionally invite karo collection dekhne ke liye. "
        "Tone: Warm, Hinglish. 2 lines max."
    ),
    "custom_jewellery": (
        "Tu A Jewel Studio ka WhatsApp assistant hai. "
        "Customer custom jewellery banana chahta hai. Poora naam maango aur thank‚Äëyou ke saath end karo. "
        "Tone: Professional, friendly, Hinglish. 2‚Äë3 lines max."
    ),
    "customer_type": (
        "Tu A Jewel Studio ka WhatsApp assistant hai. "
        "Customer ko Retail (physical jewellery) ya B2B (digital files) me se chunen. "
        "Tone: Professional, Hinglish. 1‚Äë2 lines max."
    ),
    "retail_confirm": (
        "Retail customer ka order receive hua. Professional thank‚Äëyou do. "
        "Batao ki hamari team aap se contact karegi design, pricing aur delivery ke liye. "
        "Tone: Warm, professional, Hinglish. 4‚Äë5 lines max."
    ),
    "b2b_payment": (
        "B2B customer ka order payment ke liye ready hai. "
        "Professional message do. Tone: Professional, Hinglish. 2‚Äë3 lines max."
    ),
    "b2b_success": (
        "B2B customer ki payment successful rahi. Warm thank‚Äëyou do aur batao files share ho gayi hain. "
        "Tone: Warm, professional, Hinglish. 3‚Äë4 lines max."
    ),
    "b2b_failed": (
        "Customer ki payment fail hui. Politely retry karne ko kaho. Tone: Helpful, Hinglish. 2 lines max."
    ),
    "general": (
        "Tu A Jewel Studio ka WhatsApp assistant hai. 3D jewellery designs bechta hai. "
        "Customer ke message ka professional Hinglish mein reply do. "
        "Agar samajh na aaye to 'Hi' type karne ko kaho. 3‚Äë4 lines max."
    ),
}


def gemini_reply(user_msg: str, ctx: str = "general", cust_name: str = "") -> str:
    prompt = SYSTEM_PROMPTS.get(ctx, SYSTEM_PROMPTS["general"])
    if cust_name:
        prompt += f" Customer ka naam: {cust_name}."
    payload = {
        "contents": [{"parts": [{"text": f"{prompt}\n\nCustomer: {user_msg}"}]}],
        "generationConfig": {"temperature": 0.7, "maxOutputTokens": 200},
    }
    try:
        resp = requests.post(
            f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={GEMINI_API_KEY}",
            json=payload,
            timeout=10,
        )
        data = resp.json()
        candidates = data.get("candidates")
        if not candidates:
            raise ValueError("No candidates")
        return candidates[0]["content"]["parts"][0]["text"].strip()
    except Exception as exc:
        log.error(f"Gemini error (ctx={ctx}): {exc}")
        fallback = {
            "greeting": "Namaste! A Jewel Studio mein aapka swagat hai. Menu button dabaye.",
            "registration": "Order ke liye Shopify account banana zaroori hai. Sign‚ÄëUp button dabaye.",
            "catalog": "Humara catalogue yahan hai ‚Äì dekhne ke liye button dabaye.",
            "customer_type": "Retail ya B2B (wholesale) me se chunen.",
            "b2b_payment": "Payment ke liye button dabaye.",
            "b2b_success": "Payment successful! Files download karen.",
            "b2b_failed": "Payment fail hua. Retry button dabaye.",
            "retail_confirm": "Thank you! Hamari team aap se contact karegi.",
        }
        return fallback.get(ctx, "Sorry, I didn't get that. Type *menu*.")


# ------------------------------------------------------------------
# 7Ô∏è‚É£  Helper ‚Äì send WhatsApp message
# ------------------------------------------------------------------
def wa_send(to: str, body: str, typ: str = "text", extra: Optional[dict] = None) -> None:
    url = f"https://graph.facebook.com/v18.0/{PHONE_NUMBER_ID}/messages"
    hdr = {
        "Authorization": f"Bearer {ACCESS_TOKEN}",
        "Content-Type": "application/json",
    }
    payload = {"messaging_product": "whatsapp", "to": to, "type": typ}
    if typ == "text":
        payload["text"] = {"body": body}
    else:
        payload[typ] = extra
    try:
        r = requests.post(url, headers=hdr, json=payload, timeout=10)
        r.raise_for_status()
    except Exception as exc:
        log.error(f"WhatsApp send error (to={to}, type={typ}): {exc}")


# ------------------------------------------------------------------
# 8Ô∏è‚É£  Helper ‚Äì generic Shopify GET
# ------------------------------------------------------------------
def shopify_get(endpoint: str) -> dict:
    base_url = f"https://{SHOPIFY_STORE}/admin/api/2024-04/{endpoint}"
    hdr = {
        "X-Shopify-Access-Token": get_shopify_access_token(),
        "Accept": "application/json",
    }
    try:
        r = requests.get(base_url, headers=hdr, timeout=10)
        r.raise_for_status()
        return r.json()
    except Exception as exc:
        log.error(f"Shopify GET error ({endpoint}): {exc}")
        return {}


# ------------------------------------------------------------------
# 9Ô∏è‚É£  Helper ‚Äì optional Google Sheet logging
# ------------------------------------------------------------------
def sheet() -> Optional[gspread.models.Spreadsheet]:
    if not SHEET_ID:
        return None
    try:
        cred_dict = json.loads(GOOGLE_CRED_JSON)
        creds = Credentials.from_service_account_info(
            cred_dict,
            scopes=[
                "https://www.googleapis.com/auth/spreadsheets",
                "https://www.googleapis.com/auth/drive",
            ],
        )
        client = gspread.authorize(creds)
        return client.open_by_key(SHEET_ID).sheet1
    except Exception as exc:
        log.error(f"Google Sheet init error: {exc}")
        return None


def log_to_sheet(row: List):
    sh = sheet()
    if sh:
        try:
            sh.append_row(row)
        except Exception as exc:
            log.error(f"Google Sheet write error: {exc}")


# ------------------------------------------------------------------
# 10Ô∏è‚É£  Helper ‚Äì order‚Äëid & Razorpay link
# ------------------------------------------------------------------
def generate_order_id() -> str:
    return "AJS" + datetime.now().strftime("%d%m%y%H%M%S")


def create_razorpay_link(amount_inr: float, order_id: str, name: str, phone: str) -> str:
    payload = {
        "amount": int(amount_inr * 100),
        "currency": "INR",
        "description": f"A Jewel Studio Order {order_id}",
        "customer": {"name": name, "contact": phone},
        "callback_url": "https://<your-app>.onrender.com/payment-callback",  # ‚Üê apna domain dalo
        "callback_method": "get",
        "notes": {"order_id": order_id},
    }
    try:
        resp = rzp_client.payment_link.create(payload)
        return resp.get("short_url", "")
    except Exception as exc:
        log.error(f"Razorpay link error (order={order_id}): {exc}")
        return ""


# ------------------------------------------------------------------
# 11Ô∏è‚É£  UI helpers ‚Äì MENU & CATALOG
# FIX ‚úÖ: MAX_BUTTONS = 3 (Meta sirf 3 reply-buttons allow karta hai)
# ------------------------------------------------------------------
MAX_BUTTONS = 3   # ‚Üê YAHI FIX HAI ‚Äî pehle [:10] tha, ab [:3]


def send_menu(to: str):
    wa_send(
        to,
        "Select an option:",
        "interactive",
        {
            "type": "button",
            "body": {"text": "Menu"},
            "action": {
                "buttons": [
                    {"type": "reply", "reply": {"id": "catalog", "title": "Catalog"}},
                    {"type": "reply", "reply": {"id": "custom", "title": "Custom Jewellery"}},
                ]
            },
        },
    )


def show_collections(sess: UserSession):
    data = shopify_get("custom_collections.json")
    cols = data.get("custom_collections", [])[:MAX_BUTTONS]   # ‚úÖ FIX: pehle [:10] tha
    if not cols:
        wa_send(sess.phone, "Sorry, no collections found.")
        return
    buttons = [
        {"type": "reply", "reply": {"id": str(c["id"]), "title": c["title"]}}
        for c in cols
    ]
    wa_send(
        sess.phone,
        "Select a collection:",
        "interactive",
        {"type": "button", "body": {"text": "Collections"}, "action": {"buttons": buttons}},
    )
    sess.step = "await_collection"


def show_products(sess: UserSession, collection_id: str):
    data = shopify_get(f"products.json?collection_id={collection_id}")
    prods = data.get("products", [])[:MAX_BUTTONS]            # ‚úÖ FIX: pehle [:10] tha
    if not prods:
        wa_send(sess.phone, "No products in this collection.")
        return
    buttons = [
        {"type": "reply", "reply": {"id": str(p["id"]), "title": p["title"]}} for p in prods
    ]
    wa_send(
        sess.phone,
        "Select a product:",
        "interactive",
        {"type": "button", "body": {"text": "Products"}, "action": {"buttons": buttons}},
    )
    sess.step = "await_product"
    sess.collection_id = collection_id


def show_variants(sess: UserSession, product_id: str):
    data = shopify_get(f"products/{product_id}.json")
    variants = data.get("product", {}).get("variants", [])[:MAX_BUTTONS]  # ‚úÖ FIX: pehle [:10] tha
    if not variants:
        wa_send(sess.phone, "No variants for this product.")
        return
    buttons = [
        {
            "type": "reply",
            "reply": {
                "id": str(v["id"]),
                "title": f"{v['title']} ‚Äì ‚Çπ{v['price']}",
            },
        }
        for v in variants
    ]
    wa_send(
        sess.phone,
        "Pick a variant (size/color):",
        "interactive",
        {"type": "button", "body": {"text": "Variants"}, "action": {"buttons": buttons}},
    )
    sess.step = "await_variant"
    sess.product_id = product_id


def add_variant_to_cart(sess: UserSession, variant_id: str):
    sess.cart.append(int(variant_id))
    wa_send(
        sess.phone,
        "‚úÖ Added to cart! Ab customer type chunen (Retail / B2B).",
        "interactive",
        {
            "type": "button",
            "body": {"text": "Select type"},
            "action": {
                "buttons": [
                    {"type": "reply", "reply": {"id": "retail", "title": "Retail"}},
                    {"type": "reply", "reply": {"id": "b2b", "title": "B2B / Wholesale"}},
                ]
            },
        },
    )
    sess.step = "await_customer_type"


# ------------------------------------------------------------------
# 12Ô∏è‚É£  Checkout & payment flow
# ------------------------------------------------------------------
def start_checkout(sess: UserSession) -> None:
    total = 0.0
    for vid in sess.cart:
        var = shopify_get(f"variants/{vid}.json").get("variant")
        if var:
            total += float(var.get("price", 0))

    order_id = generate_order_id()
    sess.order_id = order_id
    sess.amount = total
    sess.step = "payment_pending"

    log_to_sheet(
        [
            datetime.now().isoformat(),
            order_id,
            "B2B" if sess.customer_type == "b2b" else "Retail",
            sess.phone,
            total,
            "Pending",
        ]
    )

    link = create_razorpay_link(total, order_id, "Customer", sess.phone)
    if not link:
        wa_send(sess.phone, "Sorry, could not create payment link. Contact support.")
        return

    msg = gemini_reply(
        f"Order {order_id} ready for payment.",
        "b2b_payment" if sess.customer_type == "b2b" else "retail_confirm",
        "",
    )
    wa_send(
        sess.phone,
        msg,
        "cta_url",
        {"display_text": "Pay Now", "url": link},
    )


def payment_success(sess: UserSession) -> None:
    if sess.customer_type == "b2b":
        msg = gemini_reply("Payment successful ‚Äì B2B", "b2b_success", "")
        wa_send(sess.phone, msg)
        wa_send(
            sess.phone,
            "Your digital design files are ready.",
            "cta_url",
            {
                "display_text": "Download Now",
                "url": "https://a-jewel-studio-3.myshopify.com/a/downloads",
            },
        )
    else:
        msg = gemini_reply("Payment successful ‚Äì Retail", "retail_confirm", "")
        wa_send(sess.phone, msg)
        wa_send(
            sess.phone,
            "Our team will contact you soon for quotation & delivery details.",
            "text",
        )
    log_to_sheet([datetime.now().isoformat(), sess.order_id, "Paid"])


def payment_failed(sess: UserSession) -> None:
    msg = gemini_reply("Payment failed", "b2b_failed", "")
    new_link = create_razorpay_link(
        sess.amount or 0,
        sess.order_id or "tmp",
        "Customer",
        sess.phone,
    )
    wa_send(
        sess.phone,
        msg,
        "cta_url",
        {"display_text": "Retry Payment", "url": new_link},
    )
    log_to_sheet([datetime.now().isoformat(), sess.order_id, "Failed"])


# ------------------------------------------------------------------
# 13Ô∏è‚É£  Intent detector (free‚Äëhand Shopify queries)
# ------------------------------------------------------------------
def detect_shopify_intent(text: str):
    t = text.lower()

    if any(w in t for w in ("order", "status", "my order")):
        m = re.search(r"(\d+)\s*orders?", t)
        limit = int(m.group(1)) if m else 1
        return "order_status", {"limit": limit}

    if "gift" in t or "gift card" in t:
        return "gift_card", {}

    if "discount" in t or "coupon" in t:
        return "discounts", {}

    if any(w in t for w in ("stock", "inventory", "available", "kya mil raha")):
        m = re.search(r"(?:stock|inventory)\s+(?:of|for)\s+([a-zA-Z0-9\s]+)", t)
        product = m.group(1).strip() if m else ""
        return "inventory", {"product": product}

    if "product" in t or "item" in t:
        m = re.search(r"product\s+([a-zA-Z0-9\s]+)", t)
        product = m.group(1).strip() if m else ""
        return "product", {"product": product}

    if "return" in t or "refund" in t:
        return "returns", {}

    if any(w in t for w in ("my profile", "my details", "customer")):
        return "customer", {}

    return None, None


# ------------------------------------------------------------------
# 14Ô∏è‚É£  Shopify intent handlers
# ------------------------------------------------------------------
def fetch_customer_by_phone(phone: str) -> Optional[dict]:
    resp = shopify_get(f"customers/search.json?query=phone:{phone}")
    customers = resp.get("customers", [])
    return customers[0] if customers else None


def handler_order_status(phone: str, params: dict) -> str:
    cust = fetch_customer_by_phone(phone)
    if not cust:
        return "üôÅ Aapke phone number se koi customer record nahi mila."
    limit = params.get("limit", 1)
    orders_resp = shopify_get(
        f"orders.json?customer_id={cust['id']}&limit={limit}&order=created_at%20desc"
    )
    orders = orders_resp.get("orders", [])
    if not orders:
        return "‚ùå Aapke liye abhi tak koi order nahi hai."
    raw = json.dumps({"orders": orders}, indent=2)
    return gemini_reply(raw, ctx="general", cust_name="")


def handler_gift_card(phone: str, _: dict) -> str:
    cust = fetch_customer_by_phone(phone)
    if not cust:
        return "üôÅ Aapke phone number se koi customer nahi mila."
    gc_resp = shopify_get(f"customers/{cust['id']}/gift_cards.json")
    cards = gc_resp.get("gift_cards", [])
    if not cards:
        return "üí≥ Aapke paas abhi koi active gift‚Äëcard nahi hai."
    lines = ["ü™ô Aapke active gift‚Äëcards:"]
    for c in cards:
        bal = int(c.get("balance", 0)) / 100
        code = c.get("code", "N/A")
        expiry = c.get("expires_on", "N/A")
        lines.append(f"‚Ä¢ Code: {code} | Balance: ‚Çπ{bal:.2f} | Expiry: {expiry}")
    return "\n".join(lines)


def handler_discounts(_: str, __: dict) -> str:
    resp = shopify_get("price_rules.json?limit=5")
    rules = resp.get("price_rules", [])
    if not rules:
        return "üìâ Filhal koi active discount code nahi hai."
    lines = ["üéÅ Hamare latest discount codes:"]
    for r in rules:
        title = r.get("title", "Untitled")
        value = r.get("value", "")
        lines.append(f"‚Ä¢ {title}: {value}")
    return "\n".join(lines)


def handler_inventory(_: str, params: dict) -> str:
    product_name = params.get("product", "").strip()
    if not product_name:
        return "‚ö†Ô∏è Stock check karne ke liye product name batao."
    resp = shopify_get(f"products.json?title={product_name}")
    products = resp.get("products", [])
    if not products:
        return f"‚ùå {product_name} hamare catalog mein nahi mila."
    inventory_item_id = products[0]["variants"][0]["inventory_item_id"]
    inv_resp = shopify_get(f"inventory_levels.json?inventory_item_ids={inventory_item_id}")
    qty = inv_resp.get("inventory_levels", [{}])[0].get("available", "N/A")
    return f"‚úÖ {product_name} ka current stock: {qty} units."


def handler_product(_: str, params: dict) -> str:
    product_name = params.get("product", "").strip()
    if not product_name:
        return "‚ö†Ô∏è Product name likhiye, phir main details bhejoonga."
    resp = shopify_get(f"products.json?title={product_name}")
    products = resp.get("products", [])
    if not products:
        return f"‚ùå {product_name} hamare catalog mein nahi hai."
    raw = json.dumps(products[0], indent=2)
    return gemini_reply(raw, ctx="general", cust_name="")


def handler_returns(_: str, __: dict) -> str:
    resp = shopify_get("returns.json?limit=5")
    returns = resp.get("returns", [])
    if not returns:
        return "üì¶ Aapke liye abhi tak koi return nahi hai."
    lines = ["üîô Recent returns:"]
    for r in returns[:5]:
        oid = r.get("order_id", "N/A")
        status = r.get("status", "N/A")
        lines.append(f"‚Ä¢ Order {oid}: {status}")
    return "\n".join(lines)


def handler_customer(_: str, params: dict) -> str:
    phone = params.get("phone")
    cust = fetch_customer_by_phone(phone)
    if not cust:
        return "üôÅ Aapka customer profile nahi mila."
    name = f"{cust.get('first_name','')} {cust.get('last_name','')}".strip()
    email = cust.get("email", "N/A")
    phone = cust.get("phone", "N/A")
    return f"üë§ Aapka profile:\n‚Ä¢ Name: {name}\n‚Ä¢ Email: {email}\n‚Ä¢ Phone: {phone}"


INTENT_HANDLERS = {
    "order_status": handler_order_status,
    "gift_card":    handler_gift_card,
    "discounts":    handler_discounts,
    "inventory":    handler_inventory,
    "product":      handler_product,
    "returns":      handler_returns,
    "customer":     handler_customer,
}


# ------------------------------------------------------------------
# 15Ô∏è‚É£  Flask routes ‚Äì webhook verification & inbound messages
# ------------------------------------------------------------------
@app.route("/webhook", methods=["GET"])
def verify():
    mode = request.args.get("hub.mode")
    token = request.args.get("hub.verify_token")
    challenge = request.args.get("hub.challenge")
    if mode == "subscribe" and token == VERIFY_TOKEN:
        return challenge, 200
    return "Forbidden", 403


@app.route("/webhook", methods=["POST"])
def inbound():
    data = request.get_json()
    log.info(f"Incoming payload: {json.dumps(data)}")
    try:
        entry = data["entry"][0]["changes"][0]["value"]
        if "messages" not in entry:
            return jsonify({"status": "ok"}), 200

        msg = entry["messages"][0]
        phone = msg["from"]
        msg_type = msg["type"]

        # ---- Get or create session ----
        sess = sessions.setdefault(phone, UserSession(phone=phone))

        # ------------------------------------------------------------
        # ‚úÖ FIX: Interactive button replies PEHLE handle karo
        #    (sess.step == "new" check se PEHLE)
        #    Reason: Render restart hone par session reset ho jaata hai.
        #    Pehle "new" block pehle run hota tha aur return kar deta tha,
        #    isliye Catalog button kabhi process nahi hota tha.
        # ------------------------------------------------------------
        if msg_type == "interactive":
            btn_id = msg["interactive"]["button_reply"]["id"]

            if btn_id == "catalog":
                sess.step = "old_greeted"   # session reset ho toh bhi kaam kare
                show_collections(sess)
                return jsonify({"status": "ok"}), 200

            if btn_id == "custom":
                sess.step = "old_greeted"
                wa_send(phone, gemini_reply("", "custom_jewellery", ""), "text")
                sess.step = "await_name_custom"
                return jsonify({"status": "ok"}), 200

            if sess.step == "await_collection":
                show_products(sess, btn_id)
                return jsonify({"status": "ok"}), 200

            if sess.step == "await_product":
                show_variants(sess, btn_id)
                return jsonify({"status": "ok"}), 200

            if sess.step == "await_variant":
                add_variant_to_cart(sess, btn_id)
                return jsonify({"status": "ok"}), 200

            if sess.step == "await_customer_type":
                if btn_id in ("retail", "b2b"):
                    sess.customer_type = btn_id
                    wa_send(phone, "Kripya apna poora naam likhein:", "text")
                    sess.step = "await_name"
                return jsonify({"status": "ok"}), 200

            if sess.step == "await_name_custom":
                sess.name = btn_id
                wa_send(
                    phone,
                    f"Dhanyavaad {sess.name}! Hamari team jald hi aapko estimate bhejegi.",
                    "text",
                )
                sess.step = "finished"
                return jsonify({"status": "ok"}), 200

            # Koi aur unknown button ‚Üí menu dikhao
            send_menu(phone)
            return jsonify({"status": "ok"}), 200

        # ------------------------------------------------------------
        # 1Ô∏è‚É£  New / Existing customer detection (sirf text messages par)
        # ------------------------------------------------------------
        if sess.step == "new":
            cust_resp = shopify_get(f"customers/search.json?query=phone:{phone}")
            if cust_resp.get("customers"):
                sess.step = "old_greeted"
                greet = gemini_reply("User is returning.", "greeting", "")
                wa_send(phone, greet)
                send_menu(phone)
            else:
                sess.step = "new_greeted"
                greet = gemini_reply("New user ‚Äì ask to sign‚Äëup.", "registration", "")
                wa_send(phone, greet)
                wa_send(
                    phone,
                    "Sign‚ÄëUp",
                    "cta_url",
                    {
                        "title": "Create Shopify Account",
                        "url": f"https://{SHOPIFY_STORE}/account/register",
                    },
                )
            return jsonify({"status": "ok"}), 200

        # ------------------------------------------------------------
        # 2Ô∏è‚É£  Text messages (commands, free‚Äëhand queries, generic chat)
        # ------------------------------------------------------------
        if msg_type == "text":
            text = msg["text"]["body"].strip()

            # ---- Free‚Äëhand Shopify intent ----
            intent, params = detect_shopify_intent(text)
            if intent and intent in INTENT_HANDLERS:
                params["phone"] = phone
                reply = INTENT_HANDLERS[intent](phone, params)
                wa_send(phone, reply)
                return jsonify({"status": "ok"}), 200

            # ---- Simple static commands ----
            low = text.lower()
            if low in ("hi", "hello", "hey", "menu"):
                send_menu(phone)
                return jsonify({"status": "ok"}), 200

            if low == "checkout":
                if not sess.cart:
                    wa_send(phone, "üõí Aapka cart khaali hai ‚Äì pehle koi product jodhen.")
                elif not sess.customer_type:
                    wa_send(phone, "‚öôÔ∏è Pehle customer type (Retail / B2B) choose karein.")
                else:
                    start_checkout(sess)
                return jsonify({"status": "ok"}), 200

            # ---- Data‚Äëcapture steps (naam, contact, etc.) ----
            if sess.step and sess.step.startswith("await_"):
                field = sess.step.replace("await_", "")
                setattr(sess, field, text)

                next_map = {
                    "name": ("contact", "collect_phone"),
                    "contact": ("email", "collect_email"),
                    "email": (
                        "company" if sess.customer_type == "b2b" else "address",
                        "collect_company" if sess.customer_type == "b2b" else "collect_address",
                    ),
                    "company": ("gst", "collect_gst"),
                    "gst": ("address", "collect_address"),
                    "address": ("city", "collect_city"),
                    "city": (None, None),
                }
                nxt, prompt_key = next_map.get(field, (None, None))
                if nxt:
                    sess.step = f"await_{nxt}"
                    prompt = gemini_reply("", prompt_key, sess.name or "")
                    wa_send(phone, prompt or f"Kripya {nxt} den:")
                else:
                    wa_send(
                        phone,
                        "All details received! Type *checkout* to pay or *menu* for more options.",
                        "text",
                    )
                    sess.step = "browsing"
                return jsonify({"status": "ok"}), 200

            # ---- Generic fallback ‚Äì Gemini ----
            reply = gemini_reply(text, "general", sess.name or "")
            wa_send(phone, reply)
            return jsonify({"status": "ok"}), 200

    except Exception as exc:
        log.exception(f"Webhook processing error: {exc}")

    return jsonify({"status": "ok"}), 200


# ------------------------------------------------------------------
# 16Ô∏è‚É£  Razorpay GET callback
# ------------------------------------------------------------------
@app.route("/payment-callback", methods=["GET"])
def razorpay_callback():
    pid = request.args.get("razorpay_payment_id")
    plid = request.args.get("razorpay_payment_link_id")
    sig = request.args.get("razorpay_signature")
    status = request.args.get("razorpay_payment_link_status")

    expected = hmac.new(
        RAZORPAY_KEY_SECRET.encode(),
        f"{plid}|{pid}".encode(),
        hashlib.sha256,
    ).hexdigest()

    if expected != sig:
        log.warning("Invalid Razorpay signature")
        return "Invalid signature", 400

    for sess in list(sessions.values()):
        if sess.order_id and sess.step == "payment_pending":
            if status == "paid":
                payment_success(sess)
                sessions.pop(sess.phone, None)
            else:
                payment_failed(sess)
            break

    return "OK", 200


# ------------------------------------------------------------------
# 17Ô∏è‚É£  Razorpay POST webhook
# ------------------------------------------------------------------
@app.route("/razorpay-webhook", methods=["POST"])
def razorpay_webhook():
    payload = request.get_data()
    header_sig = request.headers.get("X-Razorpay-Signature", "")
    computed_sig = hmac.new(RAZORPAY_KEY_SECRET.encode(), payload, hashlib.sha256).hexdigest()
    if computed_sig != header_sig:
        log.warning("Razorpay webhook signature mismatch")
        return "Invalid signature", 400

    try:
        data = request.get_json()
        if data.get("event") == "payment_link.paid":
            notes = data["payload"]["payment_link"]["entity"].get("notes", {})
            order_id = notes.get("order_id")
            for sess in list(sessions.values()):
                if sess.order_id == order_id:
                    payment_success(sess)
                    sessions.pop(sess.phone, None)
                    break
    except Exception as exc:
        log.exception(f"Razorpay webhook error: {exc}")

    return "OK", 200


# ------------------------------------------------------------------
# 18Ô∏è‚É£  Daily reminder cron (21‚Äë23 h)
# ------------------------------------------------------------------
@app.route("/reminder", methods=["GET"])
def reminder():
    now = datetime.now()
    if not (21 <= now.hour <= 23):
        return "Out of window", 200

    for sess in sessions.values():
        if sess.cart and sess.step != "payment_pending":
            wa_send(
                sess.phone,
                "üõí Aapka cart abhi bhi hai ‚Äì kripya *checkout* karein ya *menu* dabayein.",
                "text",
            )
    return "Reminder sent", 200


# ------------------------------------------------------------------
# 19Ô∏è‚É£  Run Flask
# ------------------------------------------------------------------
if __name__ == "__main__":
    port = int(os.getenv("PORT", 5000))
    app.run(host="0.0.0.0", port=port, debug=False)
